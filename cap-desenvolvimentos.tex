%% ------------------------------------------------------------------------- %%
%Parte Objetiva

%\chapter{Desenvolvimentos}
%\label{cap:desenvolvimentos}
\chapter{Otimização de Parâmetros}
%-mostrar um pouco da base teórica pesquisada, com exemplos relevantes dos artigos citados
%-mencionar trabalhos relacionados, bases teóricas de AutoTuning
Otimização de parâmetros é um assunto que chama alguma atenção atualmente. Uma aplicação específica de otimização, a otimização de parâmetros consiste, basicamente, em encontrar os parâmetros que geram o resultado desejado da aplicação sendo otimizada. %<- Tenho reservas em relação ao wording daqui --Renan
Seja este objetivo a minimização do tempo de execução, ou algo como a maximização do resultado da computação feita, existem diversas maneiras de se fazer esta otimização. Até certo tempo, a única maneira de se realizar isto era por testes e esforço direto do programador, envolvendo dificuldades de implementação, testes planejados, e complexidade teórica. A otimização automatizada surgiu de um desejo de se relegar a tarefa de encontrar a melhor maneira de se executar uma tarefa para o computador. Assim sendo, diversos frameworks e aplicações surgiram, com o propósito de fazer esta otimização de forma automatizada.% --[Citation Needed]

\section{O OpenTuner}
%-explicar o que é, e o que esperamos dele
%-dar exemplos mais detalhados
%-incluir aqui nosso exemplo das árvores de habilidades
OpenTuner é um arcabouço para a implementação de sistemas de otimização e autotuning de programas. Utilizando um conjunto de técnicas empíricas de busca, o OpenTuner gera e testa combinações de parâmetros de configuração para um determinado programa, que podem representar por exemplo, escolhas algorítmicas.

Decidimos por estudar aplicações do OpenTuner no mundo real, em específico para jogos digitais. A ideia básica é que podemos usar o OpenTuner para otimizar um conjunto de parâmetros dentro do jogo, para ajudar o jogador a ter um planejamento, ou como uma metaferramenta de auxílio. Exemplos são a otimização de: parâmetros de inteligências artificiais para obter comportamentos desejáveis; parâmetros de geradores de mapas para obter ambientes variados com características comuns desejáveis; e a distribuição de pontos em personagens de um RPG (Role-Playing Game).

%TODO: Outras ideias
%Eram o que? SaltyBet, builds, IAs e gerção de mapa?
%OpenTTD vai onde?
\chapter{Ideias iniciais}
Texto

\chapter{OpenTTD}
\section{O jogo}
%-explicar os básicos sobre o jogo
%-explicar os nosso objetivos em aplicar o OpenTuner sobre ele
%-explicar como exatamente integramos os dois

%Miojo notes: OpenTTD se chama OpenTTD, simplesmente. Não é abreviação de Open Transport Tycoon Deluxe, embora seja </pedantic>
O OpenTTD é um clone de código aberto do clássico jogo Transport Tycoon Deluxe. Neste jogo, o jogador assume o papel de um administrador de uma empresa de transportes, e pode gerenciar e construir diversas redes de transporte, desde alugar e operar linhas de ônibus, até construir ferrovias e aeroportos. O objetivo do jogo é livre, sendo normalmente considerado apenas como criar uma linha de transporte eficiente, ou maximizar os lucros que sua empresa gera. Por esse fato, e pela simplicidade de lidar com o jogo, este foi escolhido para ser tratado neste trabalho.
 
OpenTTD foi baseado no jogo original de 1994, que recebeu um patch feito pela comunidade em 1996. A versão de código aberto foi lançada como uma derivação de tal patch chamado TTDPatch, que visava resolver alguns problemas de ordem técnica do jogo, além de adicionar algumas funcionalidades como novos gráficos, veículos,e indústrias. Entretanto,este patch não podia alterar facetas mais profundas do jogo original, e era limitado aos sistemas e plataformas nos quais este poderia ser executado. Seguindo o mesmo espírito deste patch, o OpenTTD foi criado como uma obra de engenharia reversa do jogo original, recriando-o em linguagem C. Este processo começou em 2003, por autoria de Ludvig Strigeus, que desejava uma maneira de continuar jogando Transport Tycoon Deluxe que se adaptasse à novas tecnologias, e pudesse ser modificado de maneiras mais profundas pela comunidade. O jogo foi lançado oficialmente em 2004, e até o ano de 2010, este ainda era dependente dos gráficos, músicas e efeitos sonoros do jogo original. Estes recursos foram gradualmente substituídos por versões feitas pela comunidade, tornando-o independente dos materiais do jogo original. %[Citation needed?]
%WebRef/Footnote pro About do site do OpenTTD

%BEGIN RASCUNHO

IAs existem, e são em Squirrel, que é uma linguadem de script com sintaxe tipo C++.

%END RASCUNHO

\section{Objetivos}

%BEGIN RASCUNHO

Conseguir integrar? Ver se funciona? E resultados vem de brinde se funcionar e forem interessantes?

%END RASCUNHO

\section{Integração}

%Acho que aqui vai mais ou menos a estrutura do tuner?

%BEGIN RASCUNHO

Composto por módulos TTDTuner, que interage com o OpenTuner, TTDHandler, que interage com o OpenTTD, e o AIBuilder, que constrói as IAs. Além disso, uma IA base, que é uma versão modificada e incompleta da IA ChooChoo. Essa IA, além de ter os custos de pathfinding removidos para serem determinados pelo tuner, tem outputs a mais para relatar o resultado depois de um certo tempo. Tem um config que determina a pasta onde está a IA base, onde fica o diretório de IAs do OpenTTD, e qual o comando pra chamar o OpenTTD. Por linha de comando, dá pra especificar qual valor observar, quantos anos dura cada iteração da simulação, e quantas IAs existirão por iteração. Os valores medidos podem ser valor da empresa, lucro no último quartil, ou dinheiro em caixa.

Primeiro, conversar com o OpenTuner. Módulo chamado TTDTuner. Conversa com OpenTuner, pega as configurações, escolhe um número de ID e chama o AIBuilder, que constrói a IA e coloca na pasta de IAs do OpenTTD, e em seguida avisa pro handler iniciar essas IAs no jogo. Em seguida, ele espera a iteração terminar e recebe os resultados do Handler, e pede para o mesmo reiniciar o jogo. Por último, ele tira a média dos resultados observados e envia isso para o OpenTuner.

O builder funciona substituindo linhas com palavras-chave pré-determinadas em cada um dos arquivos a serem modificados, com cada palavra-chave sendo mapeada a uma substituição diferente. A lista de palavras-chave e esse mapeamento é independente para cada arquivo. O AIBuilder recebe um vetor de custos, um nome de parâmetro a ser avaliado, um número de anos e um ID do TTDTuner, que são usados para construir adequadamente as instruções que serão inseridas no código da IA gerada. O nome da IA é determinado pelo ID recebido, e é passado de volta para o tuner.

O Handler cuida do OpenTTD. Ele envia comandos para o servidor via pipe para o stdin do servidor e lê os outputs dele. Ele é responsável por iniciar IAs, parar IAs, ler respostas, e reiniciar o servidor quando necessário. Após iniciar as IAs, ele espera um output do jogo que respeita um formato específico, definido pelo pasrão de output do OpenTTD e por uma convenção adotada para o ajuste fino. Ao detectar essa saída, que contém o resultado obtido e a identificação da IA, ele concatena esse resultado a um vetor de resultados, e devolve esse vetor quando todas as IAs terminarem.

Por fim, o OpenTTD foi compilado para rodar muito mais rápido, mas o tuner funciona mesmo sem essa modificação, mas demora muito mais. %<- Top quality writing

%END RASCUNHO

\chapter{Experimentos}

%BEGIN RASCUNHO

Para ver se o Tuner funcionava, foram realizados testes de 10 e 50 anos com 8 IAs por iteração para valor da empresa, e de 10 anos com 6 IAs e 30 anos com 8 IAs para dinheiro em caixa e lucro. Testes de 10 anos foram executados numa máquina virtual cedida pelo Gnann e os testes mais longos foram feitos na Rá, o servidor web do USPGameDev. A intenção original era rodar esses testes por uma semana, mas crashes em pontos arbitrários, ocorrendo entre 8 e 72 horas após o início dos testes. Para os testes de caixa e lucro, o valor de semente inicial para o gerador de mapa do OpenTTD foi fixado, mas não durante os testes de valor da empresa, porque derp. Um dia, existirão gráficos mostrando os resultados. Por enquanto, faça de conta que a linha abaixo são os gráficos:

-----------------------------------------

Apesar de todos os experimentos terem sido muito mais curtos do que inicialmente planejado, houve melhoras observadas pelo tuner. Ainda não foi feita a comparação com a IA original. E tudo isso sem o OpenTuner saber como funciona o OpenTTD!

BTW, tentaram entrar no jogo da Rá, mas não conseguiram porque o servidor, compilado em modo gotta go fast, achava que os clientes eram lentos demais e dropou as conexões.

%END RASCUNHO
%-coisas que aconteceram

%-Estrutura do programa
% Construtor <-> Tuner <-> Handler <-> Server de OpenTTD
% OpenTTD gambiarrado pra gotta go fast
% Máquinas:
%  máquina virtual cedida pelo Gnann, carinhosamente chamada derrota
%  ra, o servidor web do uspgamedev
%  não zillertal porque faltava uma biblioteca que somehow só fazia falta de vez em quando e que eu esqueci de pedir pra instalarem

%Insofar, experimentos apenas com valor da companhia.
%Also, não guardamos as configurações. Deveríamos corrigir isso.

%Embora neste exemplo tenhamos apenas um capítulo,  entre a introdução
%e a conclusão de uma monografia podemos ter uma sequência de capítulos
%descrevendo o trabalho e os resultados. Estes podem descrever
%fundamentos, trabalhos relacionados, método/modelo/algoritmo proposto,
%experimentos realizados, resultados obtidos.
%
%Cada capítulo pode ser organizado em seções, que por sua vez pode
%conter subseções. 

%Um exemplo de figura está na figura~\ref{fig:graph}.
%\begin{figure}[htb]
%\includegraphics[width=5cm]{figuras/graph}
%\caption{\label{fig:graph}Exemplo de uma figura.}
%\end{figure}
