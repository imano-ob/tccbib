%% ------------------------------------------------------------------------- %%
%Parte Objetiva

%\chapter{Desenvolvimentos}
%\label{cap:desenvolvimentos}
\chapter{Fundamentação Teórica}
\section{Otimização de Parâmetros}
%-mostrar um pouco da base teórica pesquisada, com exemplos relevantes dos artigos citados
%-mencionar trabalhos relacionados, bases teóricas de AutoTuning
%TODO: arrumar essa frase abaixo
Otimização de parâmetros é um assunto que levanta certo interesse atualmente. Ela consiste em encontrar os parâmetros que otimizam uma aplicação.
Seja este objetivo a minimização do tempo de execução, ou algo como a maximização do resultado da computação feita, existem diversas maneiras de se fazer esta otimização. A maneira mais utilizada de se realizar isto era por testes e esforço direto do programador, envolvendo dificuldades de implementação, testes planejados, e complexidade teórica. A otimização automatizada surgiu de um desejo de se relegar a tarefa de encontrar a melhor maneira de se executar uma tarefa para o computador. Diversos arcabouços e aplicações surgiram, com o propósito de fazer esta otimização de forma automatizada (\cite{hoos2012programming}).

Em desenvolvimento, sempre existem diferentes maneiras de se resolver um problema. Seja pelo uso de diferentes algoritmos, diferentes modelagens do problema, ou aproximações alternativas. Quando se está trabalhando em algum problema, normalmente estes diversos métodos são considerados, e os métodos que melhor resolvem o problema são escolhidos e focados. Como tal, não é comum que maneiras diferentes sejam implementadas de maneira conjunta, sendo que a melhor escolha normalmente é uma escolha genérica, e pode apresentar performance reduzida em casos incomuns; isto é levado em consideração no momento da escolha como uma consequência de se fixar um método.

O processo de otimização então, consiste em métodos de se escolher esta melhor maneira de resolver um problema. Aqui pode-se perceber que esta escolha é outro problema a ser resolvido, que requisita esforço extra por parte do desenvolvedor. Planejar, testar, comparar e escolher os métodos a serem usados são tarefas que levam um tempo considerável. Quando ainda existe a implementação de mais de um método, usualmente a escolha entre estes fica por conta de alterar parâmetros do programa. Parâmetros estes que são muitas vezes fixados no desenvolvimento, como constantes ou símbolos no código.

Hoos diz, em seu trabalho Programming by Optimization (Programar por Otimização, \cite{hoos2012programming}), que em sua experiência na área de desenvolvimento de solucionadores heurísticos de alta performance performance para diversos problemas combinatórios difíceis, construir software otimizado manualmente pelo desenvolvedor leva a resultados sub-otimais em termos de performance. Esse resultado mencionado se deve à tentativas de otimizar manualmente algoritmos complexos de maneira a fixar um método de resolução de mecanismos heurísticos, devido à escolhas de design feitas com base em intuição, experiência prévia ou alguma experimentação por parte do desenvolvedor. O que então é sugerido no artigo de Hoos, é o conceito de \textit{Programar por Otimização}, que consiste em desenvolver diversas soluções para um mesmo problema, e utilizar um algoritmo que escolha quais são os melhores usos de cada solução. Hoos descreve uma plataforma de PbO que realiza o trabalho deste algoritmo de escolha para o desenvolvedor. Dados um problema, um código contendo diversas maneiras de se resolver este problema, e um \textit{weaver} de PbO, é realizado um algoritmo que os trata como um problema de otimização estocástica. Essa otimização meta-algorítmica recebe um espaço de design, e um conjunto de entrada, e gera um solucionador que apresenta a melhor combinação de parâmetros que leva à uma melhor performance. Esse método gera um código estático que possui as características desejadas, mas apenas para os casos relacionados. Os conceitos e métodos apresentados aqui aproximam-se muito de \textit{autotuning}, na forma que ambos levam à uma otimização algorítmica de um programa. 

Combinando as ideias de Programming by Optimization e \textit{autotuning}, existe o PetaBricks (\cite{ansel2009petabricks}), que é uma combinação de linguagem implicitamente paralela e de seu compilador, onde ter múltiplas implementações de múltiplos algoritmos para resolver um problema é a maneira natural de programar . O compilador do PetaBricks realiza o trabalho de \textit{autotuning} sobre o código, fazendo tanto escolhas algorítmicas quanto escolhas de ajuste fino sobre os parâmetros do programa. O compilador também é responsável por fazer escolhas de técnicas automáticas de paralelização, distribuições de dados, parâmetros algorítmicos e transformações, entre outros.

\textit{Autotuning} vem sendo usado em áreas como computação de alta performance e computação gráfica. Foi mostrado que consegue-se uma performance melhor, ou pelo menos mais portável, utilizando-se \textit{autotuning} comparado a desenvolver sem o uso da mesma (\cite{ansel2014opentuner}). Mas, ainda assim, existem problemas e desafios relacionados com a aplicação de \textit{autotuning} a projetos. Primeiramente, existe o problema de que \textit{tuners} são normalmente desenvolvidos de maneira específica para uma aplicação, de maneira que não podem ser usados com aplicações diferentes; também por este motivo, \textit{tuners} são trabalhosos de se implementar, por necessitar não apenas o desenvolvimento da aplicação base, mas um estudo de seus diferentes possíveis algoritmos, e de seu espaço de configurações. Este esforço é muitas vezes considerado proibitivo em tempo de desenvolvimento. 

Os desafios que são encontrados no desenvolvimento de \textit{frameworks} de \textit{autotuning} são, principalmente (\cite{ansel2014opentuner}): encontrar a melhor representação de parâmetros para o programa; o tamanho do espaço de configurações válido, que pode ser proibitivamente grande (podendo passar de $10^{30}$ no nosso exemplo); e a complexidade topográfica deste espaço de configurações. Configurações podem ser representadas por diversos meios diferentes, desde simples valores numéricos, a listas e árvores de escolha representando um conjunto de instruções. Fica sob a responsabilidade do desenvolvedor escolher uma representação do problema que faça sentido para o \textit{autotuner} de maneira que a mesma possa ser tratada, o que altera a lógica do uso do \textit{tuner}. Depois de se fixar uma representação, deve-se haver uma preocupação com o tamanho do espaço de configurações, pois o mesmo pode ser demasiadamente grande, atingindo números de possibilidade que podem ser facilmente maiores que a quantidade de átomos do universo, que é da ordem de grandeza de $10^{79}$\footnote{\url{http://www.madsci.org/posts/archives/oct98/905633072.As.r.html}, visitado em 29/11/15}. Não apenas extensos, espaços de configurações são geralmente complexos, contendo ao mesmo tempo alta dimensionalidade, seções de crescimento ou decrescimento estáveis, platôs de continuidade, grandes espaços descontínuos, áreas onde certos parâmetros são altamente relacionados e parâmetros completamente independentes entre si, dentre muitas outras características. Diferentes algoritmos de navegação destes espaços trabalham melhor com características diversas no espaço de busca, e se dedicar exclusivamente à uma ou poucas delas pode gerar falsos ótimos, ou uma falha em obter-se uma otimização que efetivamente melhore a performance do programa. 

Para tratar destes desafios então, foi desenvolvido um \textit{framework} de \textit{autotuning}, o OpenTuner (\cite{ansel2014opentuner}). O OpenTuner permite a construção de \textit{autotuners} específicos de aplicação de forma genérica, utilizando-se das suas próprias técnicas de busca para realizar a otimização via parâmetros da aplicação, desde que esta tenha alguma interface com o OpenTuner. Assim, qualquer problema que possa ter sua entrada representada por parâmetros e uma saída quantificável pode ser otimizado com este \textit{framework}. Ele define tipos de dados e técnicas de busca, que tornam fácil preparar um novo projeto.

\section{O OpenTuner}
%-explicar o que é, e o que esperamos dele
%-dar exemplos mais detalhados
%-incluir aqui nosso exemplo das árvores de habilidades
OpenTuner é um arcabouço para a implementação de sistemas de otimização e ajuste fino de programas. Utilizando um conjunto de técnicas empíricas de busca, o OpenTuner gera e testa combinações de parâmetros de configuração para um determinado programa, que podem representar por exemplo, escolhas algorítmicas.

Decidimos por estudar aplicações do OpenTuner no mundo real, em específico para jogos digitais. A ideia básica é que podemos usar o OpenTuner para otimizar um conjunto de parâmetros dentro do jogo, para ajudar o jogador a ter um planejamento, ou como uma metaferramenta de auxílio. Exemplos são a otimização de: parâmetros de inteligências artificiais para obter comportamentos desejáveis; parâmetros de geradores de mapas para obter ambientes variados com características comuns desejáveis; e a distribuição de pontos em personagens de um RPG (Role-Playing Game).

\begin{figure}[h]
	\centering
	\includegraphics[width=0.7\linewidth]{OpenTuner}
	\caption{Diagrama de Funcionamento do OpenTuner}
	\label{fig:OpenTuner}
\end{figure}
\centering{Fonte: \cite{ansel2014opentuner}}

O OpenTuner é 

%TODO: Outras ideias
%Eram o que? SaltyBet, builds, IAs e gerção de mapa?
%OpenTTD vai onde?
\section{Estudos Preliminares}
Inicialmente, desejávamos utilizar o OpenTuner em otimização de parâmetros em geradores de mapas. Seu propósito seria ser uma metaferramenta sobre o gerador de mapas de algum jogo, para otimizar a geração aleatória ou determinística de mapas com características desejáveis e quantificáveis.

Várias ideias de diferentes jogos possíveis foram sugeridas, e inicialmente concordamos em utilizar um gerador de mapas para o jogo DooM. Sendo um jogo consideravelmente antigo e simples, o trabalho seria também simples. Não só existem implementações \textit{open-source} do mesmo, como conseguimos encontrar um gerador de mapas de simples uso que poderia ser usado em \textit{autotuning}.

O fato de DooM ser um jogo muito antigo foi desfavorável ao projeto. Uma boa parte da comunidade de desenvolvedores de conteúdo sobre o jogo é extremamente antiga, com seus sites e fóruns foram desativados ou estão grandemente desatualizados. Mas o maior problema era  de ordem conceitual: como quantificar a qualidade de um mapa? Para o processo de \textit{autotuning}, é necessário um resultado numérico, que não se pode derivar facilmente de um mapa, sem técnicas mais complexas; e mesmo que um valor fosse derivado, não havia como garantir que era uma representação acurada da \textit{fitness} do mapa. %<- Lies. Dá sim. E dá pra pegar número que fazem sentido. Isso não significa que seja fácil ou uma modelagem perfeita.
%Expandir essa ideia!
Foi considerada a ideia de usar um \textit{bot}, um personagem controlado por IA, como função de \textit{fitness} para o mapa, como maneira de quantificar a qualidade do mapa, mas informações sobre o funcionamento do jogo são escassas. O plano inicial seria realizar \textit{autotuning} no gerador de mapas, e como uma maneira de "otimização dupla" utilizar um \textit{bot} pré-otimizado para avaliar se o mapa gerado contém as características necessárias. Quantidade de inimigos, tempo decorrido até o mapa ser completado pelo \textit{bot}, quantidade de recursos gastos, seriam os valores avaliados pelo \textit{autotuner}. O tamanho da tarefa de encontrar um jogo, um gerador de mapas e um conjunto de \textit{bot} com os quais se pudesse trabalhar provou-se grande demais para o escopo deste trabalho.

Próximo na lista de ideias estava a otimização da distribuição de pontos para um personagem de RPG (Role-Playing Game, ou jogo de interpretação de papeis). Para cada personagem em um jogo de RPG, existe um conjunto de atributos, com pontos que podem ser distribuídos entre eles; para cada atributo, uma determinada quantidade de pontos afeta de forma diferente os resultados finais que um personagem pode ter no decorrer do jogo (um maior valor de Força, por exemplo, acarreta em ataques mais poderosos). Computacionalmente é uma questão muito mais simples, pois com este exemplo consegue-se derivar diretamente os valores a serem otimizados. Exemplos destes valores são: a quantidade de pontos de vida que um personagem possui ou quantos pontos de dano o mesmo causa com um ataque.

A escolha de qual jogo se usaria de base torna-se então o problema. Deve-se considerar a complexidade do jogo em si, dado que isto influencia diretamente a maneira de se modelar a distribuição de pontos no OpenTuner. Foi iniciada a implementação de um \textit{autotuner} simples com uma árvore de habilidades genérica como exemplo, para verificação de como o programa se comportaria, e se ele daria os resultados ótimos dentro de um bom tempo de execução.

Ideias de jogos a serem modelados foram: Torchlight 2\footnote{\url{http://www.torchlight2game.com/}}, Path of Exile\footnote{\url{https://www.pathofexile.com/}}, The Elder Scrolls V: Skyrim\footnote{\url{http://www.elderscrolls.com/skyrim/}}, jogos do tipo Rogue-like\footnote{\url{https://pt.wikipedia.org/wiki/Roguelike}}, League of Legends\footnote{\url{http://br.leagueoflegends.com/}}, DOTA 2\footnote{\url{http://br.dota2.com/}}, e até algum possível sistema de RPG de mesa. Alguns destes foram descartados imediatamente por motivos como dificuldade de modelagem da árvore ou aleatoriedade demasiada envolvida no processo de testes.

Foi considerado então possivelmente trabalhar com os jogos Torchlight 2 ou The Elder Scrolls V: Skyrim. Estes dois jogos possuem árvores de habilidades razoavelmente simples conceitualmente, então era necessário verificar a viabilidade da interação dos mesmos com o Python, para fazer-se a interface com o OpenTuner. Novos problemas foram encontrados, na forma de incompatibilidades técnicas. As comunidades de desenvolvimento de conteúdo de Torchlight e de Skyrim trabalham primariamente com ferramentas fornecidas pelos desenvolvedores, que envolvem plataformas e linguagens de \textit{scripting} próprias dos jogos, sem interação com linha de comando externa, ou possibilidade de alteração de atributos de personagem por ferramentas externas ao jogo. Em ambos os jogos, de maneiras similares, apenas é possível manipular o jogo com uma ferramenta externa própria, feita pelos desenvolvedores, ou internamente por um console isolado do sistema operacional, com comandos limitados. Adicionalmente, tentativas de alterar os arquivos de dados de personagem dos jogos mostraram-se demasiadamente complexas, por envolverem arquivos encriptados de forma complexa, e não existir nenhum método diretamente acessível de realizar esta decodificação.

Uma ideia que foi sugerida à parte destas outras, apenas pela discussão dos métodos, foi criar um \textit{bot} que apostasse no site SaltyBet. Este site consiste de uma \textit{stream} de vídeo com um jogo de luta sem jogadores, apenas com IAs controlando os personagens. Usuários que acessam o site podem apostar dinheiro virtual, referido como "Salt Dollars", em qual personagem preferirem. O \textit{bot} leria as entradas do chat, onde os personagens envolvidos e os resultados são anunciados, e daria estas informações para o OpenTuner. O OpenTuner, por sua vez, gravaria os resultados obtidos, e escolheria a \textit{a melhor estratégia de apostas} para decidir em qual personagem se apostaria, e quanto. Sendo apenas uma discussão de viabilidade, esta ideia não foi seguida.

Finalmente, o jogo que foi escolhido para este estudo de viabilidade foi o OpenTTD. É um simulador de gerência de empresa de transportes, o que o distancia dos gêneros dos jogos estudados anteriormente. O que realmente causou a sua escolha para o projeto foram o fato de o mesmo ser um jogo de código aberto, e a existência de uma simples forma de interface com a linha de comando do sistema.

\chapter{OpenTTD}
\section{O jogo}
%-explicar os básicos sobre o jogo
%-explicar os nosso objetivos em aplicar o OpenTuner sobre ele
%-explicar como exatamente integramos os dois

O OpenTTD \footnote{\url{www.openttd.org}}  é um clone de código aberto do clássico jogo Transport Tycoon Deluxe. Neste jogo, o jogador assume o papel de um administrador de uma empresa de transportes, e pode gerenciar e construir diversas redes de transporte, desde alugar e operar linhas de ônibus, até construir ferrovias e aeroportos. O objetivo do jogo é livre, sendo normalmente considerado apenas como criar uma linha de transporte eficiente, ou maximizar os lucros que sua empresa gera. Por este fato, e pela simplicidade de lidar com o jogo, esse foi escolhido para ser tratado neste trabalho.
 
\begin{figure}[h]
	\centering
	\includegraphics[width=0.9\linewidth]{OpenTTDtitle}
	\caption{Tela Inicial do OpenTTD}
	\label{fig:OpenTTDtitle}
\end{figure}
 
OpenTTD foi baseado no jogo original de 1994, que recebeu um patch feito pela comunidade em 1996. A versão de código aberto foi lançada como uma derivação de tal patch chamado TTDPatch, que visava resolver alguns problemas de ordem técnica do jogo, além de adicionar algumas funcionalidades como novos gráficos, veículos,e indústrias. Entretanto,este \textit{patch} não podia alterar facetas mais profundas do jogo original, e era limitado aos sistemas e plataformas nos quais este poderia ser executado. Seguindo o mesmo espírito deste \textit{patch}, o OpenTTD foi criado como uma obra de engenharia reversa do jogo original, recriando-o em linguagem C. Este processo começou em 2003, por autoria de Ludvig Strigeus, que desejava uma maneira de continuar jogando Transport Tycoon Deluxe que se adaptasse a novas tecnologias, e pudesse ser modificado de maneiras mais profundas pela comunidade. O jogo foi lançado oficialmente em 2004, e até o ano de 2010, este ainda era dependente dos gráficos, músicas e efeitos sonoros do jogo original. Estes recursos foram gradualmente substituídos por versões feitas pela comunidade, tornando-o independente dos materiais do jogo original.\footnote{\url{https://www.openttd.org/en/about}}

\begin{figure}[h]
	\centering
	\includegraphics[width=0.7\linewidth]{screenshot-openttd}
	\caption{Screenshot de gameplay do OpenTTD}
	\label{fig:OpenTTDSS}
\end{figure}

O OpenTTD tem suporte a execução como servidor dedicado, sem interface gráfica. Nesse modo, a interação com ele se dá através de um console, que aceita comandos pré-determinados, como iniciar uma IA ou reiniciar o jogo, e escreve na saída padrão e na saída de erro os acontecimentos do jogo. 

\section{Inteligências Artificiais}
O OpenTTD tem suporte a inteligências artificiais, cujo comportamento é definido por um conjunto de scripts Squirrel, que é descrita pelos seus desenvolvedores como uma linguagem de \textit{scripting} de alto nível, imperativa e orientada a objetos, projetada para ser leve e se adequar aos requerimentos de banda, memória e processamento de aplicações como jogos\footnote{\url{www.squirrel-lang.org}}. Sua sintaxe é bastante similar à de C++. O OpenTTD tem seu próprio interpretador Squirrel, que executa um certo número de instruções de cada IA antes de interrompê-la por um breve período de tempo. Estes scripts são responsáveis por todas as ações que a IA pode tomar, como quais pontos de produção e consumo atender com seus veículos, como construir um caminho que atenda a este transporte, e quais veículos utilizar para isso.

Explicar como as IAs ficam na pasta do OpenTTD

Explicar como é o funcionamento básico de uma IA genérica

Explicar como podemos interagir com uma IA

\chapter{Implementação}
\section{Objetivos}

Para avaliar a aplicabilidade de técnicas de ajuste fino em jogos, neste trabalho foi feito um \textit{tuner} para o vetor de custos de Pathfinding para construção de trilhos da IA, por ser um conjunto de valores mais simples de se trabalhar. Serão observados fatores como facilidade de implementação, funcionamento adequado e resultados obtidos. 

\section{Integração}

O \textit{tuner} implementado é composto pelo módulos TTDTuner, TTDHandler e AIBuilder. O TTDTuner interage com o OpenTuner, TTDHandler interage com o OpenTTD, e o AIBuilder constrói as IAs. Além destes, uma IA base que é uma versão modificada e incompleta dos arquivos da IA ChooChoo\footnote{\url{http://www.tt-forums.net/viewtopic.php?t=44225}}. Essa IA, além de ter os custos de pathfinding removidos para serem determinados pelo \textit{autotuner}, tem mensagens de saída adicionadas para relatar os resultados depois de um certo tempo. Existe um arquivo de configuração, o qual determina a pasta onde está a IA base, onde fica o diretório de IAs do OpenTTD, e qual o comando a ser utilizado para iniciar o OpenTTD. Por linha de comando, pode-se especificar qual valor será observado, quantos anos irá duras cada iteração da simulação, e quantas IAs existirão por iteração. Os valores medidos podem ser valor da empresa, lucro no último quartil, ou dinheiro em caixa.

O TTDTuner recebe as configurações do OpenTuner, escolhe um número de ID e inicia o AIBuilder, o qual constrói uma IA e a coloca na pasta apropriada do OpenTTD, e devolve o nome da IA gerada. Em seguida, o TTDTuner repassa esse nome para o TTDHandler, que carrega estas IAs no jogo. O TTDTuner então aguarda o final da iteração, marcado pelo recebimento dos resultados vindos do TTDHandler, e então requisita que o mesmo reinicie a sessão de jogo. Por final, a média dos resultados é tirada e enviada para o OpenTuner. 
%Miojo notes: primeiro, o AIBuilder nem sabe que o handler existe, então ele não pode mandar sinal nenhum. Dois, sinal tem um significado bem específico, e não é isso que acontece. É só uma chamada de método, guys.

O AIBuilder funciona substituindo linhas com palavras-chave pré-determinadas em cada um dos arquivos a serem modificados, com cada palavra-chave sendo mapeada a uma substituição diferente. A lista de palavras-chave e o mapeamento destas é independente para cada arquivo. O AIBuilder recebe um vetor de custos, um nome de parâmetro a ser avaliado, um número de anos e um ID do TTDTuner, que são usados para construir adequadamente as instruções que serão inseridas no código da IA gerada. O nome da IA é determinado pelo ID recebido, e é passado de volta para o TTDTuner.

O TTDHandler realiza a interface com o OpenTTD. Ele envia comandos para o servidor via pipe para o stdin do servidor e lê a saída retornada. O TTDHandler é responsável por iniciar IAs, parar IAs, ler respostas, e reiniciar o servidor quando necessário. Após iniciar as IAs, ele espera uma saída em formato específico vinda do jogo, formato este definido pelo padrão do OpenTTD e por uma convenção adotada para o ajuste fino realizado aqui. Ao detectar esta saída, que contém o resultado obtido e a identificação da IA, o TTDHandler concatena este resultado em um vetor, e devolve esse vetor quando todas as IAs terminarem.

\begin{figure}
\centering
\includegraphics[width=0.7\linewidth]{Diagrama1}
\caption{Estrutura do \textit{tuner} implementado}
\label{fig:Diagrama1}
\end{figure}

%-coisas que aconteceram

%-Estrutura do programa
% Construtor <-> Tuner <-> Handler <-> Server de OpenTTD
% OpenTTD gambiarrado pra gotta go fast
% Máquinas:
%  máquina virtual cedida pelo Gnann, carinhosamente chamada derrota
%  ra, o servidor web do uspgamedev
%  não zillertal porque faltava uma biblioteca que somehow só fazia falta de vez em quando e que eu esqueci de pedir pra instalarem

\section{Experimentos e Resultados}

Para verificar o funcionamento do \textit{autotuner}, foram realizados testes de 10 e 50 anos com 8 IAs por iteração para valor da empresa, e de 10 anos com 6 IAs e 30 anos com 8 IAs para dinheiro em caixa e lucro. Testes de 10 anos foram executados numa máquina virtual cedida por William Gnann, com 512MB RAM e um núcleo de um processador AMD Opteron 2210, e os testes mais longos foram feitos na Rá, o servidor web do USPGameDev, com 4GB de RAM e um processador Intel Xeon X3430. Ambas estavam com o sistema operacional Debian 7.

Para a realização dos experimentos relacionados neste trabalho, o OpenTTD foi compilado com uma alteração de uma \textit{flag} que permite que os ciclos de jogo passem de forma muito mais rápida que o natural. Assim, a passagem de tempo dentro do jogo é acelerada de modo a possibilitar a geração de mais resultados em menos tempo. Os testes realizam rodadas de 10, 30 e 50 anos dentro do jogo, sendo que um ano de jogo dura aproximadamente 13 minutos. Realizar baterias de testes levando 10 horas cada uma seria proibitivo. 

A intenção original seria rodar esses testes por uma semana, mas instabilidades causando que os mesmos fossem interrompidos ocorriam em pontos imprevisíveis da execução, entre 8 e 72 horas após o início dos testes. Para os testes de caixa e lucro, o valor de semente inicial para o gerador de mapa do OpenTTD foi fixado, mas não durante os testes de valor da empresa. Esta alteração foi pensada depois dos testes iniciais, como uma maneira de eliminar a influência de aleatoriedade do ambiente do jogo sobre os resultados. 
%Miojo notes: na real eu tinha tentado fixar, mas eu não tenho certeza se estava. Eu chuto que não. Eventualmente eu decidi passar como argumento que era mais certeza.

Apesar de todos os experimentos terem sido muito mais curtos do que inicialmente planejado, houve melhoras observadas pelo \textit{tuner}. Ainda não foi feita a comparação com a IA original.

Uma observação à parte sobre os testes realizados: em determinado momento durante os testes no servidor Rá, foi tentada uma conexão externa com as instâncias de teste do jogo. O próprio sistema do jogo recusou a conexão, por assumir que o cliente estava rodando em uma velocidade lenta demais para a conexão. Isto aconteceu devido à compilação para alta velocidade feita para o OpenTTD.

\begin{figure}[h!]\centering
	\begin{subfigure}{0.4\textwidth}\includegraphics[width=1\linewidth]{value-50yrs}
	\end{subfigure}
	\begin{subfigure}{0.4\textwidth}
		\includegraphics[width=1\linewidth]{value-50yrs-best}
	\end{subfigure}
	\caption{Experimento de valor de 50 anos}
	\label{fig:value-50yrs}
\end{figure}

\begin{figure}[h!]\centering
	\begin{subfigure}{0.4\textwidth}\includegraphics[width=1\linewidth]{value-10yrs}
	\end{subfigure}
	\begin{subfigure}{0.4\textwidth}
		\includegraphics[width=1\linewidth]{value-10yrs-best}
	\end{subfigure}
	\caption{Experimento de valor de 10 anos}
	\label{fig:value-10yrs}
\end{figure}

\begin{figure}[h!]\centering
	\begin{subfigure}{0.4\textwidth}\includegraphics[width=1\linewidth]{profit-30yrs}
	\end{subfigure}
	\begin{subfigure}{0.4\textwidth}
		\includegraphics[width=1\linewidth]{profit-30yrs-best}
	\end{subfigure}
	\caption{Experimento de lucro de 30 anos}
	\label{fig:profit-30yrs}
\end{figure}

\begin{figure}[h!]\centering
	\begin{subfigure}{0.4\textwidth}\includegraphics[width=1\linewidth]{profit-10yrs}
	\end{subfigure}
	\begin{subfigure}{0.4\textwidth}
		\includegraphics[width=1\linewidth]{profit-10yrs-best}
	\end{subfigure}
	\caption{Experimento de lucro de 10 anos}
	\label{fig:profit-10yrs}
\end{figure}

\begin{figure}[h!]\centering
	\begin{subfigure}{0.4\textwidth}\includegraphics[width=1\linewidth]{money-30yrs}
	\end{subfigure}
	\begin{subfigure}{0.4\textwidth}
		\includegraphics[width=1\linewidth]{money-30yrs-best}
	\end{subfigure}
	\caption{Experimento de caixa de 30 anos}
	\label{fig:money-30yrs}
\end{figure}

\begin{figure}[h!]\centering
	\begin{subfigure}{0.4\textwidth}\includegraphics[width=1\linewidth]{money-10yrs}
	\end{subfigure}
	\begin{subfigure}{0.4\textwidth}
		\includegraphics[width=1\linewidth]{money-10yrs-best}
	\end{subfigure}
	\caption{Experimento de caixa de 10 anos}
	\label{fig:money-10yrs}
\end{figure}



