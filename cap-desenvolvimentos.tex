%% ------------------------------------------------------------------------- %%
%Parte Objetiva

%\chapter{Desenvolvimentos}
%\label{cap:desenvolvimentos}
\chapter{Fundamentação Teórica}
\section{Otimização de Parâmetros}
%-mostrar um pouco da base teórica pesquisada, com exemplos relevantes dos artigos citados
%-mencionar trabalhos relacionados, bases teóricas de AutoTuning
Otimização de parâmetros consiste em encontrar os parâmetros que otimizam uma aplicação. Seja este objetivo a minimização do tempo de execução, ou algo como a maximização do resultado da computação feita, existem diversas maneiras de se fazer esta otimização. A maneira mais utilizada de se realizar isto era por testes e esforço direto do programador, envolvendo dificuldades de implementação, testes planejados, e complexidade teórica. A otimização automatizada surgiu de um desejo de se relegar a tarefa de encontrar a melhor maneira de se executar uma tarefa para o computador. Diversos arcabouços e aplicações surgiram, com o propósito de fazer esta otimização de forma automatizada (\cite{hoos2012programming}).

Em desenvolvimento de software, sempre existem diferentes maneiras de se resolver um problema encontrado pelo desenvolvedor, seja pelo uso de diferentes algoritmos, diferentes modelagens do problema, ou aproximações alternativas. Quando se está trabalhando em algum problema, normalmente estes diversos métodos são considerados, e os que melhor resolvem o problema são escolhidos e implementados. Esta escolha se baseia em diversos fatores, dentre os quais a eficiência, a corretude e o esforço de implementação são os mais importantes. Devido a este fato, a solução escolhida é uma que apresenta um bom desempenho \textit{na média}, para um caso genérico do problema. Escolher uma solução genérica implica em sacrifícios de desempenho em casos incomuns (\cite{tiwari2011auto}).

O processo de otimização consiste em métodos de se escolher esta melhor maneira de resolver um problema. Esta escolha é outro problema a ser resolvido, que requisita esforço extra por parte do desenvolvedor. Planejar, testar, comparar e escolher os métodos a serem usados são tarefas que levam um tempo considerável. Quando ainda existe a implementação de mais de um método, usualmente a escolha entre estes fica por conta de alterar parâmetros do programa. Parâmetros estes que são muitas vezes fixados no desenvolvimento, como constantes ou símbolos no código.

Hoos diz, em seu trabalho Programming by Optimization (Programar por Otimização, \cite{hoos2012programming}), que em sua experiência na área de desenvolvimento de solucionadores heurísticos de alta performance para diversos problemas combinatórios difíceis, construir software otimizado manualmente pelo desenvolvedor leva a resultados sub-otimais em termos de performance. Esse resultado mencionado se deve à tentativas de otimizar manualmente algoritmos complexos de maneira a fixar um método de resolução de um problema, devido à escolhas de design feitas pelo desenvolvedor baseadas em intuição, experiência prévia ou alguma experimentação. O que então é sugerido no artigo de Hoos, é o conceito de PbO, que consiste em desenvolver diversas soluções para um mesmo problema, e utilizar um algoritmo que escolha quais são os melhores usos de cada solução. Hoos descreve uma plataforma de PbO que realiza o trabalho deste algoritmo de escolha para o desenvolvedor. Dados um problema, um código contendo diversas maneiras de se resolver este problema, e um \textit{weaver} de PbO, é realizado pela plataforma então, um algoritmo que os trata como um problema de otimização estocástica. O \textit{weaver} é responsável por tomar as partes do código a serem otimizadas e os trechos que contém as otimizações, e reuni-los em um único código coeso, funcional e otimizado.
Esta otimização meta-algorítmica recebe um espaço de design, e um conjunto de entrada, e gera um solucionador que apresenta a melhor combinação de parâmetros que leva a uma melhor performance. Esse método gera um código estático que possui as características desejadas, mas apenas para os casos relacionados. Os conceitos e métodos apresentados aqui aproximam-se muito de \textit{autotuning}, na forma que ambos levam à uma otimização algorítmica de um programa. 

Combinando as ideias de Programming by Optimization e \textit{autotuning}, existe o PetaBricks (\cite{ansel2009petabricks}), que é uma combinação de linguagem implicitamente paralela e de seu compilador, onde ter múltiplas implementações de múltiplos algoritmos para resolver um problema é a maneira natural de programar. O compilador do PetaBricks realiza o trabalho de \textit{autotuning} sobre o código, fazendo tanto escolhas algorítmicas quanto escolhas de ajuste fino sobre os parâmetros do programa. O compilador também é responsável por fazer escolhas de técnicas automáticas de paralelização, distribuições de dados, parâmetros algorítmicos e transformações, entre outros.

\textit{Autotuning} vem sendo usado em áreas como computação de alta performance e computação gráfica. Foi mostrado que consegue-se uma performance melhor, ou pelo menos mais portável, utilizando-se \textit{autotuning} comparado a desenvolver sem o uso da mesma (\cite{ansel2014opentuner}). Mas, ainda assim, existem problemas e desafios relacionados com a aplicação de \textit{autotuning} a projetos. Primeiramente, existe o problema de que \textit{autotuners} são normalmente desenvolvidos de maneira específica para uma aplicação, de maneira que não podem ser usados com aplicações diferentes; também por este motivo, \textit{autotuners} são trabalhosos de se implementar, por necessitar não apenas o desenvolvimento da aplicação base, mas um estudo de seus diferentes possíveis algoritmos, e de seu espaço de configurações. Este esforço é muitas vezes considerado proibitivo em tempo de desenvolvimento. 

Os desafios que são encontrados no desenvolvimento de \textit{frameworks} de \textit{autotuning} são, principalmente (\cite{ansel2014opentuner}): encontrar a melhor representação de parâmetros para o programa; o tamanho do espaço de configurações válido, que pode ser proibitivamente grande (podendo passar de $10^{30}$ no nosso exemplo); e a complexidade topográfica deste espaço de configurações. Configurações podem ser representadas por diversos meios diferentes, desde simples valores numéricos, a listas e árvores de escolha representando um conjunto de instruções. Fica sob a responsabilidade do desenvolvedor escolher uma representação do problema que faça sentido para o \textit{autotuner} de maneira que a mesma possa ser tratada, o que altera a lógica do uso do \textit{tuner}. Depois de se fixar uma representação, deve-se haver uma preocupação com o tamanho do espaço de configurações, pois o mesmo pode ser demasiadamente grande, atingindo números de possibilidade que podem ser facilmente maiores que a quantidade de átomos do universo, que é da ordem de grandeza de $10^{79}$ \footnote{\url{http://www.madsci.org/posts/archives/oct98/905633072.As.r.html}, visitado em 29/11/15}. Não apenas extensos, espaços de configurações são geralmente complexos, contendo ao mesmo tempo alta dimensionalidade, seções de crescimento ou decrescimento estáveis, platôs de continuidade, grandes espaços descontínuos, áreas onde certos parâmetros são altamente relacionados e parâmetros completamente independentes entre si, dentre muitas outras características. Diferentes algoritmos de navegação destes espaços trabalham melhor com características diversas no espaço de busca, e se dedicar exclusivamente à uma ou poucas delas pode gerar falsos ótimos, ou uma falha em obter-se uma otimização que efetivamente melhore a performance do programa. 

Para tratar destes desafios então, foi desenvolvido um \textit{framework} de \textit{autotuning}, o OpenTuner (\cite{ansel2014opentuner}). O OpenTuner permite a construção de \textit{autotuners} específicos de aplicação de forma genérica, utilizando-se das suas próprias técnicas de busca para realizar a otimização via parâmetros da aplicação, desde que esta tenha alguma interface com o OpenTuner. Assim, qualquer problema que possa ter sua entrada representada por parâmetros e uma saída quantificável pode ser otimizado com este \textit{framework}. Ele define tipos de dados e técnicas de busca, que tornam fácil preparar um novo projeto.

\section{O OpenTuner}
%-explicar o que é, e o que esperamos dele
%-dar exemplos mais detalhados
%THIS v
%-incluir aqui nosso exemplo das árvores de habilidades
%THIS ^
OpenTuner é um arcabouço para a implementação de sistemas de otimização e ajuste fino de programas. Utilizando um conjunto de técnicas empíricas de busca, o OpenTuner gera e testa combinações de parâmetros de configuração para um determinado programa, que podem representar por exemplo, escolhas algorítmicas.

OpenTuner introduziu o conceito de utilizar conjuntos de técnicas de busca para \textit{autotuning} de programas, o que permite que um número de técnicas diferentes trabalhem em conjunto para encontrar uma solução ótima. Estes conjuntos incluem técnicas refinadas de busca, preparadas para navegar espaços complexos, e utilizar representações mais sofisticadas de dados; isto permite que problemas de complexidade maior sejam resolvidos, de uma maneira que pode ser adaptada por diversos projetos. O OpenTuner é capaz de encontrar resultados em espaços de busca muito grandes, passando de $10^{3600}$ possibilidades, como relatado no artigo (\cite{ansel2014opentuner}).

O OpenTuner trata o problema de \textit{autotuning} como um problema de busca. O espaço de busca é composto de configurações, que são atribuições concretas de um conjunto de parâmetros. Parâmetros podem assumir diversas formas, como números simples, ou conjuntos complexos de dados. Um resultado é gerado executando-se o conjunto de configurações em uma forma específica ao seu domínio, e pode ser medido em performance, corretude da resposta ou outras métricas. Técnicas de busca são responsáveis por alterar as configurações utilizando manipuladores definidos pelo usuário. A figura \ref{fig:OpenTuner} ilustra a organização do funcionamento do OpenTuner.

\begin{figure}[h]
	\centering
	\includegraphics[width=0.7\linewidth]{OpenTuner}
	\caption{Diagrama de Funcionamento do OpenTuner}
	\label{fig:OpenTuner}
\end{figure}
Fonte: \cite{ansel2014opentuner}\\

O sistema de conjuntos de busca do OpenTuner funciona agregando diversas técnicas de busca em uma metatécnica, que delega a busca a uma delas. Dessa forma, é possível montar uma hierarquia de técnicas e metatécnicas que permita a melhor solução para cada problema. O mecanismo de busca base do OpenTuner age em cima apenas de uma técnica, geralmente uma metatécnica. A metatécnica central do OpenTuner é a \textit{multi-armed bandit with sliding window, area under the curve credit assignment (AUC Bandit)}, baseada numa solução ótima para o problema de múltiplos caça-níqueis \cite{fialho2010analyzing}. Esse problema consiste em encontrar um equilíbrio entre, dadas múltiplas máquinas caça-níquel, explorar quais são os que oferecem melhores recompensas e utilizar com mais frequência os que possuem resultados melhores. Para este trabalho, foram utilizados os métodos de busca padrão do OpenTuner.

Decidimos por estudar aplicações do OpenTuner no mundo real, em específico para jogos digitais. A ideia básica é que podemos usar o OpenTuner para otimizar um conjunto de parâmetros dentro do jogo, para ajudar o jogador a ter um planejamento, ou como uma metaferramenta de auxílio. Exemplos são a otimização de: parâmetros de inteligências artificiais para obter comportamentos desejáveis; parâmetros de geradores de mapas para obter ambientes variados com características comuns desejáveis; e a distribuição de pontos em personagens de um RPG (Role-Playing Game).

\section{Estudos Preliminares}
Inicialmente, era desejado a utilização do OpenTuner em otimização de parâmetros em geradores de mapas. Seu propósito seria ser uma metaferramenta sobre o gerador de mapas de algum jogo, para otimizar a geração aleatória ou determinística de mapas com características desejáveis e quantificáveis.

Várias ideias de diferentes jogos possíveis foram elencadas, e inicialmente foi decidida a utilização de um gerador de mapas para o jogo DooM. Sendo um jogo consideravelmente antigo e simples, o trabalho seria também simples. Não só existem implementações \textit{open-source} do mesmo, como foi encontrado um gerador de mapas de simples uso que poderia ser usado em \textit{autotuning}.

O fato de DooM ser um jogo muito antigo foi desfavorável ao projeto. Uma boa parte da comunidade de desenvolvedores de conteúdo sobre o jogo é extremamente antiga, com seus sites e fóruns desativados ou grandemente desatualizados. Mas o maior problema era  de ordem conceitual: como quantificar a qualidade de um mapa? Para o processo de \textit{autotuning}, é necessário um resultado numérico, que não se pode derivar facilmente de um mapa, sem técnicas mais complexas; e mesmo que um valor fosse derivado, não havia como garantir que era uma representação acurada da \textit{fitness} do mapa. A \textit{fitness} do mapa seria um valor ou conjunto de valores extraídos algoritmicamente do mapa, de forma que fosse possível que outros algoritmos o julgassem como um mapa "bom" ou "ruim" de acordo com as regras colocadas pelo desenvolvedor.
%<- Lies. Dá sim. E dá pra pegar número que fazem sentido. Isso não significa que seja fácil ou uma modelagem perfeita.

Foi considerada a ideia de usar um \textit{bot}, um personagem controlado por IA, como função de \textit{fitness} para o mapa, como maneira de quantificar a qualidade do mapa, mas informações sobre o funcionamento do jogo são escassas. O plano inicial seria realizar \textit{autotuning} no gerador de mapas, e como uma maneira de "otimização dupla" utilizar um \textit{bot} pré-otimizado para avaliar se o mapa gerado contém as características necessárias. Quantidade de inimigos, tempo decorrido até o mapa ser completado pelo \textit{bot}, quantidade de recursos gastos, seriam os valores avaliados pelo \textit{autotuner}. O tamanho da tarefa de encontrar um jogo, um gerador de mapas e um conjunto de \textit{bot} com os quais se pudesse trabalhar provou-se grande demais para o escopo deste trabalho.

Próximo na lista de ideias estava a otimização da distribuição de pontos para um personagem de RPG (Role-Playing Game, ou jogo de interpretação de papeis). Para cada personagem em um jogo de RPG, existe um conjunto de atributos, com pontos que podem ser distribuídos entre eles; para cada atributo, uma determinada quantidade de pontos afeta de forma diferente os resultados finais que um personagem pode ter no decorrer do jogo (um maior valor de Força, por exemplo, acarreta em ataques mais poderosos). Computacionalmente é uma questão muito mais simples, pois com este exemplo consegue-se derivar diretamente os valores a serem otimizados. Exemplos destes valores são: a quantidade de pontos de vida que um personagem possui ou quantos pontos de dano o mesmo causa com um ataque.

A escolha de qual jogo se usaria de base torna-se então o problema. Deve-se considerar a complexidade do jogo em si, dado que isto influencia diretamente a maneira de se modelar a distribuição de pontos no OpenTuner. Foi iniciada a implementação de um \textit{autotuner} simples com uma árvore de habilidades genérica como exemplo, para verificação de como o programa se comportaria, e se ele daria os resultados ótimos dentro de um bom tempo de execução.
%Explicar o que é uma árvore de habilidades genérica

Ideias de jogos a serem modelados foram: Torchlight 2\footnote{\url{http://www.torchlight2game.com/}, visitado em 29/11/15}, Path of Exile\footnote{\url{https://www.pathofexile.com/}, visitado em 29/11/15}, The Elder Scrolls V: Skyrim\footnote{\url{http://www.elderscrolls.com/skyrim/}, visitado em 29/11/15}, jogos do tipo Rogue-like\footnote{\url{https://pt.wikipedia.org/wiki/Roguelike}, visitado em 29/11/15}, League of Legends\footnote{\url{http://br.leagueoflegends.com/}, visitado em 29/11/15}, DOTA 2\footnote{\url{http://br.dota2.com/}, visitado em 29/11/15}, e até algum possível sistema de RPG de mesa. Alguns destes foram descartados imediatamente por motivos como dificuldade de modelagem da árvore ou aleatoriedade demasiada envolvida no processo de testes.

Foi considerada então a possibilidade de trabalhar com os jogos Torchlight 2 ou The Elder Scrolls V: Skyrim. Estes dois jogos possuem árvores de habilidades razoavelmente simples conceitualmente; então era necessário verificar a viabilidade da interação dos mesmos com o Python, para fazer-se a interface com o OpenTuner. Novos problemas foram encontrados, na forma de incompatibilidades técnicas. As comunidades de desenvolvimento de conteúdo de Torchlight e de Skyrim trabalham primariamente com ferramentas fornecidas pelos desenvolvedores, que envolvem plataformas e linguagens de \textit{scripting} próprias dos jogos, sem interação com linha de comando externa, ou possibilidade de alteração de atributos de personagem por ferramentas externas ao jogo. Em ambos os jogos, de maneiras similares, apenas é possível manipular o jogo com uma ferramenta externa própria, feita pelos desenvolvedores, ou internamente por um console isolado do sistema operacional, com comandos limitados. Adicionalmente, tentativas de alterar os arquivos de dados de personagem dos jogos mostraram-se demasiadamente complexas, por envolverem arquivos encriptados de forma complexa, e não existir nenhum método diretamente acessível de realizar esta decodificação.

Uma ideia que foi sugerida à parte destas outras, apenas pela discussão dos métodos, foi criar um \textit{bot} que apostasse no site SaltyBet. Este site consiste de uma \textit{stream} de vídeo com um jogo de luta sem jogadores, apenas com IAs controlando os personagens. Usuários que acessam o site podem apostar dinheiro virtual, referido como "Salt Dollars", no resultado da luta. O \textit{bot} leria as entradas do chat, onde os personagens envolvidos e os resultados são anunciados, e daria estas informações para o OpenTuner. O OpenTuner, por sua vez, gravaria os resultados obtidos, e escolheria a \textit{melhor estratégia de apostas} para decidir em qual personagem se apostaria, e quanto. Sendo apenas uma discussão de viabilidade, esta ideia não foi seguida.

Finalmente, o jogo que foi escolhido para este estudo de viabilidade foi o OpenTTD. É um simulador de gerência de empresa de transportes, o que o distancia dos gêneros dos jogos estudados anteriormente. O que realmente causou a sua escolha para o projeto foram o fato de o mesmo ser um jogo de código aberto, e a existência de uma simples forma de interface com a linha de comando do sistema.

\chapter{OpenTTD}
\section{O jogo}
%-explicar os básicos sobre o jogo
%-explicar os nosso objetivos em aplicar o OpenTuner sobre ele
%-explicar como exatamente integramos os dois

O OpenTTD \footnote{\url{www.openttd.org}}  é um clone de código aberto do clássico jogo Transport Tycoon Deluxe. Neste jogo, o jogador assume o papel de um administrador de uma empresa de transportes, e pode gerenciar e construir diversas redes de transporte, desde operar linhas de ônibus, até construir ferrovias e aeroportos. 
%Explicar melhor o objetivo do jogo
O objetivo do jogo é livre, sendo normalmente considerado apenas como criar uma linha de transporte eficiente, ou maximizar os lucros que sua empresa gera. Por este fato, e pela simplicidade de lidar com o jogo, esse foi escolhido para ser tratado neste trabalho.
 
\begin{figure}[h]
	\centering
	\includegraphics[width=0.9\linewidth]{OpenTTDtitle}
	\caption{Tela Inicial do OpenTTD}
	\label{fig:OpenTTDtitle}
\end{figure}
 
OpenTTD foi baseado no jogo original de 1994, que recebeu um \textit{patch} feito pela comunidade em 1996. A versão de código aberto foi lançada como uma derivação de tal patch chamado TTDPatch, que visava resolver alguns problemas de ordem técnica do jogo, além de adicionar algumas funcionalidades como novos gráficos, veículos e indústrias. Entretanto,este \textit{patch} não podia alterar facetas mais profundas do jogo original, e era limitado aos sistemas e plataformas nos quais este poderia ser executado. Seguindo o mesmo espírito deste \textit{patch}, o OpenTTD foi criado como uma obra de engenharia reversa do jogo original, recriando-o em linguagem C. Este processo começou em 2003, por autoria de Ludvig Strigeus, que desejava uma maneira de continuar jogando Transport Tycoon Deluxe que se adaptasse a novas tecnologias, e pudesse ser modificado de maneiras mais profundas pela comunidade. O jogo foi lançado oficialmente em 2004, e até o ano de 2010, este ainda era dependente dos gráficos, músicas e efeitos sonoros do jogo original. Estes recursos foram gradualmente substituídos por versões feitas pela comunidade, tornando-o independente dos materiais do jogo original.\footnote{\url{https://www.openttd.org/en/about}, visitado em 29/11/15}

\begin{figure}[h]
	\centering
	\includegraphics[width=0.7\linewidth]{screenshot-openttd}
	\caption{Screenshot de gameplay do OpenTTD}
	\label{fig:OpenTTDSS}
\end{figure}

No jogo, a única forma de se ganhar dinheiro é com o transporte de produtos ou passageiros de um lugar de origem, que produz esses recursos, até um local de destino, que os consome. Cada local produtor produz recursos diferentes, como uma fazenda que produz grãos e gado, e cada local consumidor consome um recurso diferente, como uma fábrica consome aço, grãos ou gado.
Alguns consumidores, por sua vez, geram outros produtos ao consumirem, como as já mencionadas fábricas, que ao receberem recursos, produzem bens.
Para cada tipo de recurso, porém, não há discriminação além de que tipo é produzido ou consumido.
Isso significa, por exemplo, que passageiros embarcam em qualquer estação e sempre desembarcam na próxima, não tendo um destino específico. O dinheiro recebido a cada transporte depende do tempo entre a produção e o consumo, e a distância entre o produtor e o consumidor. 
Quanto maior a demora, menor o pagamento, e quanto maior a distância, maior o dinheiro recebido. 
A carga e descarga é realizada em estações dedicadas, que devem estar próximas dos pontos de interesse. 
É possível juntar estações de veículos diferentes para serem tratados como uma única estação, compartilhando recursos que podem ser transportados por cada um dos veículos que a utilizam.

Além disso, há diversos meios de transporte, cada um com suas características. 
Trens, por exemplo, são caros, precisam de um vagão dedicado à locomoção e vagões separados para carga, e circulam apenas em ferrovias, mas são rápidos e têm uma quantidade ajustável de carga que pode ser transportada, de acordo com o número de vagões dedicados a cada tipo de produto. 
Caminhões e ônibus, por outro lado, são baratos e capazes de carregar produtos sem mais auxílio, mas são lentos e tem pouca capacidade. 
Há também aviões e navios que podem ser utilizados. 
Existem diversos modelos diferentes para cada uma dessas categorias. A seleção de veículos muda conforme o tempo do jogo progride, com novos modelos tornando-se disponíveis e os antiquados não podendo mais ser adquiridos.

O OpenTTD tem suporte a execução como servidor dedicado, sem interface gráfica. 
Nesse modo, a interação com ele se dá através de um console, que aceita comandos pré-determinados, como iniciar uma IA ou reiniciar o jogo, e escreve na saída padrão e na saída de erro os acontecimentos do jogo. 

\section{Inteligências Artificiais}

O OpenTTD tem suporte a inteligências artificiais, cujo comportamento é definido por um conjunto de \textit{scripts} Squirrel, que é descrita pelos seus desenvolvedores como uma linguagem de \textit{scripting} de alto nível, imperativa e orientada a objetos, projetada para ser leve e se adequar aos requerimentos de banda, memória e processamento de aplicações como jogos\footnote{\url{www.squirrel-lang.org}, visitado em 29/11/15}.
Sua sintaxe é bastante similar à de C++. O OpenTTD tem seu próprio interpretador Squirrel, que executa um certo número de instruções de cada IA antes de interrompê-la por um breve período de tempo. 
Estes \textit{scripts} são responsáveis por todas as ações que a IA pode tomar, como quais pontos de produção e consumo atender com seus veículos, como construir um caminho que atenda a este transporte, e quais veículos utilizar para isso.

Cada conjunto de \textit{scripts} fica dentro de uma pasta, que fica em um diretório pertencente ao de configurações do OpenTTD. Esse diretório de IAs também pode incluir bibliotecas para o uso de outras IAs. 
Cada IA deve ter ao menos um \textit{script} de informações de identificação da IA e um \textit{script} principal que deve conter um \textit{loop} infinito com o funcionamento da mesma. 
Cada IA pode ter também qualquer número de \textit{scripts} auxiliares, que devem ficar na mesma pasta e serem chamados a partir do \textit{script} principal.
Essas IAs podem ser instanciadas durante o jogo, e cada uma que seja iniciada passa a assumir o controle de uma companhia, cujo comportamento é definido pelos seus \textit{scripts}.

\chapter{Implementação}
\section{Objetivos}

Para avaliar a aplicabilidade de técnicas de ajuste fino em jogos, neste trabalho foi feito um \textit{tuner} para o vetor de custos de \textit{Pathfinding} para construção de trilhos da IA, por ser um conjunto de valores mais simples de se trabalhar. Serão observados fatores como facilidade de implementação, funcionamento adequado e resultados obtidos. Para este trabalho, foram utilizados os métodos de busca padrão do OpenTuner.
%Explicar (por alto) o vetor de custos do pathfinder, e o que é otimizado nele

\section{Integração}

O \textit{autotuner} implementado \ref{fig:Diagrama1} é composto pelo módulos TTDTuner, TTDHandler e AIBuilder. O TTDTuner interage com o OpenTuner, TTDHandler interage com o OpenTTD, e o AIBuilder constrói as IAs. Além destes, uma IA base que é uma versão modificada e incompleta dos arquivos da IA ChooChoo\footnote{\url{http://www.tt-forums.net/viewtopic.php?t=44225}, visitado em 29/11/15}. Essa IA, além de ter os custos de \textit{pathfinding} removidos para serem determinados pelo \textit{autotuner}, tem mensagens de saída adicionadas para relatar os resultados depois de um certo tempo. Existe um arquivo de configuração, o qual determina a pasta onde está a IA base, onde fica o diretório de IAs do OpenTTD, e qual o comando a ser utilizado para iniciar o OpenTTD. Por linha de comando, pode-se especificar qual valor será observado, quantos anos irá durar cada iteração da simulação, e quantas IAs existirão por iteração. Os valores medidos podem ser valor da empresa, lucro no último quartil, ou dinheiro em caixa.

O TTDTuner recebe as configurações do OpenTuner, escolhe um número de ID e inicia o AIBuilder, o qual constrói uma IA e a coloca na pasta apropriada do OpenTTD, e devolve o nome da IA gerada. Em seguida, o TTDTuner repassa esse nome para o TTDHandler, que carrega estas IAs no jogo. O TTDTuner então aguarda o final da iteração, marcado pelo recebimento dos resultados vindos do TTDHandler, e então requisita que o mesmo reinicie a sessão de jogo. Por final, a média dos resultados é tirada e enviada para o OpenTuner. 

O AIBuilder funciona substituindo linhas com palavras-chave pré-determinadas em cada um dos arquivos a serem modificados, com cada palavra-chave sendo mapeada a uma substituição diferente. A lista de palavras-chave e o mapeamento destas é independente para cada arquivo. O AIBuilder recebe um vetor de custos, um nome de parâmetro a ser avaliado, um número de anos e um ID do TTDTuner, que são usados para construir adequadamente as instruções que serão inseridas no código da IA gerada. O nome da IA é determinado pelo ID recebido, e é passado de volta para o TTDTuner.

O TTDHandler realiza a interface com o OpenTTD. Ele envia comandos para o servidor via pipe para o stdin do servidor e lê a saída retornada. O TTDHandler é responsável por iniciar IAs, parar IAs, ler respostas, e reiniciar o servidor quando necessário. Após iniciar as IAs, ele espera uma saída em formato específico vinda do jogo, formato este definido pelo padrão do OpenTTD e por uma convenção adotada para o ajuste fino realizado aqui. Ao detectar esta saída, que contém o resultado obtido e a identificação da IA, o TTDHandler concatena este resultado em um vetor, e devolve esse vetor quando todas as IAs terminarem.

\begin{figure}
\centering
\includegraphics[width=0.7\linewidth]{Diagrama1}
\caption{Estrutura do \textit{tuner} implementado}
\label{fig:Diagrama1}
\end{figure}

\section{Experimentos e Resultados}

Para verificar o funcionamento do \textit{autotuner}, foram realizados testes de 10 e 50 anos com 8 IAs por iteração para valor da empresa, e de 10 anos com 6 IAs e 30 anos com 8 IAs para dinheiro em caixa e lucro. Testes de 10 anos foram executados numa máquina virtual cedida por William Gnann, com 512MB RAM e um núcleo de um processador AMD Opteron 2210, e os testes mais longos foram feitos na Rá, o servidor web do USPGameDev, com 4GB de RAM e um processador Intel Xeon X3430. Ambas estavam com o sistema operacional Debian 7.

Os testes consistem de uma execução do \textit{autotuner}, onde, a cada rodada, é escolhida uma configuração para o vetor de custos do \textit{pathfinder} da IA, o jogo instancia o número determinados de cópias dessa IA, os resultados observados são coletados e informados de volta para o OpenTuner, que escolhe uma nova configuração para a próxima iteração com base nos resultados observados.

Para a realização dos experimentos relacionados neste trabalho, o OpenTTD foi compilado com uma alteração de uma \textit{flag} que permite que os ciclos de jogo passem de forma muito mais rápida que o natural. Assim, a passagem de tempo dentro do jogo é acelerada de modo a possibilitar a geração de mais resultados em menos tempo. Os testes realizam rodadas de 10, 30 e 50 anos dentro do jogo, sendo que um ano de jogo dura aproximadamente 13 minutos. Realizar baterias de testes levando 10 horas cada uma seria proibitivo. 

A intenção original seria rodar esses testes por uma semana, mas instabilidades causando que os mesmos fossem interrompidos ocorriam em pontos imprevisíveis da execução, entre 8 e 72 horas após o início dos testes. Para os testes de caixa e lucro, o valor de semente inicial para o gerador de mapa do OpenTTD foi fixado, mas não durante os testes de valor da empresa. Esta alteração foi pensada depois dos testes iniciais, como uma maneira de eliminar a influência de aleatoriedade do ambiente do jogo sobre os resultados. 
%Miojo notes: na real eu tinha tentado fixar, mas eu não tenho certeza se estava. Eu chuto que não. Eventualmente eu decidi passar como argumento que era mais certeza.

Apesar de todos os experimentos terem sido muito mais curtos do que inicialmente planejado, houve melhoras observadas pelo \textit{autotuner}. Ainda não foi feita a comparação com a IA original.

Uma observação à parte sobre os testes realizados: em determinado momento durante os testes no servidor Rá, foi tentada uma conexão externa com as instâncias de teste do jogo. O próprio sistema do jogo recusou a conexão, por assumir que o cliente estava rodando em uma velocidade lenta demais para a conexão. Isto aconteceu devido à compilação para alta velocidade feita para o OpenTTD.

%comentar a diferença e relação entre os gráficos
A seguir, estão os gráficos criados com os resultados obtidos nos experimentos. Pode-se verificar, no geral, que o OpenTuner consegue obter resultados melhores conforme mais iterações passam. Na figura \ref{fig:value-50yrs}, podemos ver que as iterações iniciais mantiveram-se em uma média, mas valores melhores foram encontrados em iterações mais elevadas, como era de se esperar. Este teste ainda continha uma certa variância estocástica por interação do gerador de mapas com os testes; a semente do gerador não havia ainda sido fixada, o que causou as alterações radicais de valor observadas.
\begin{figure}[h!]\centering
	\begin{subfigure}{0.4\textwidth}\includegraphics[width=1\linewidth]{value-50yrs}
	\end{subfigure}
	\begin{subfigure}{0.4\textwidth}
		\includegraphics[width=1\linewidth]{value-50yrs-best}
	\end{subfigure}
	\caption{Experimento de valor de 50 anos}
	\label{fig:value-50yrs}
\end{figure}

Na figura \ref{fig:value-10yrs} pode-se ver os resultados de um teste similar, ainda utilizando o valor da empresa como resultado observado. As diferenças deste teste em relação ao anterior foram a duração de cada iteração e o gerador de mapas ter sua semente fixada. Isto remove o fator aleatório do mapa do teste, possibilitando resultados mais acurados. A redução da duração foi feita como uma maneira de se obter mais resultados, pois iterações de 50 anos levavam muito tempo para serem completas.
\begin{figure}\centering
	\begin{subfigure}{0.4\textwidth}\includegraphics[width=1\linewidth]{value-10yrs}
	\end{subfigure}
	\begin{subfigure}{0.4\textwidth}
		\includegraphics[width=1\linewidth]{value-10yrs-best}
	\end{subfigure}
	\caption{Experimento de valor de 10 anos}
	\label{fig:value-10yrs}
\end{figure}

\begin{figure}\centering
	\begin{subfigure}{0.4\textwidth}\includegraphics[width=1\linewidth]{profit-30yrs}
	\end{subfigure}
	\begin{subfigure}{0.4\textwidth}
		\includegraphics[width=1\linewidth]{profit-30yrs-best}
	\end{subfigure}
	\caption{Experimento de lucro de 30 anos}
	\label{fig:profit-30yrs}
\end{figure}

\begin{figure}\centering
	\begin{subfigure}{0.4\textwidth}\includegraphics[width=1\linewidth]{profit-10yrs}
	\end{subfigure}
	\begin{subfigure}{0.4\textwidth}
		\includegraphics[width=1\linewidth]{profit-10yrs-best}
	\end{subfigure}
	\caption{Experimento de lucro de 10 anos}
	\label{fig:profit-10yrs}
\end{figure}

Nas figuras \ref{fig:profit-30yrs} e \ref{fig:profit-10yrs} podemos ver testes realizados utilizando uma forma diferente de verificar o resultado. Nestes testes, o lucro da empresa ao final de cada iteração foi medido, como uma alternativa ao valor da empresa. Utilizando o lucro, pode-se ter uma visão melhor do crescimento da empresa sobre os anos, e pode-se observar a melhora encontrada pelas técnicas de busca do OpenTuner. 

\begin{figure}\centering
	\begin{subfigure}{0.4\textwidth}\includegraphics[width=1\linewidth]{money-30yrs}
	\end{subfigure}
	\begin{subfigure}{0.4\textwidth}
		\includegraphics[width=1\linewidth]{money-30yrs-best}
	\end{subfigure}
	\caption{Experimento de caixa de 30 anos}
	\label{fig:money-30yrs}
\end{figure}

\begin{figure}\centering
	\begin{subfigure}{0.4\textwidth}\includegraphics[width=1\linewidth]{money-10yrs}
	\end{subfigure}
	\begin{subfigure}{0.4\textwidth}
		\includegraphics[width=1\linewidth]{money-10yrs-best}
	\end{subfigure}
	\caption{Experimento de caixa de 10 anos}
	\label{fig:money-10yrs}
\end{figure}

Por fim, são mostrados os gráficos dos experimentos onde o valor em caixa ao final de cada quartil foi medido. Pode-se observar na figura \ref{fig:money-10yrs} que, em casos em que não são executadas muitas iterações, o OpenTuner pode encontrar um melhor resultado nas primeiras iterações, e suas técnicas de busca não conseguem encontrar resultados melhores por algum tempo. Com iterações suficientes, como pode-se observar na figura \ref{fig:money-30yrs}, é possível ver um crescimento estável do resultado, mostrando que as técnicas de busca conseguiram funcionar corretamente.

