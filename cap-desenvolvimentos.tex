%% ------------------------------------------------------------------------- %%
%Parte Objetiva

%\chapter{Desenvolvimentos}
%\label{cap:desenvolvimentos}
\chapter{Otimização de Parâmetros}
%-mostrar um pouco da base teórica pesquisada, com exemplos relevantes dos artigos citados
%-mencionar trabalhos relacionados, bases teóricas de AutoTuning
Otimização de parâmetros é um assunto que chama alguma atenção atualmente. Ela consiste, basicamente, em encontrar os parâmetros que geram o resultado desejado de uma aplicação sendo otimizada. %<- Tenho reservas em relação ao wording daqui --Renan
Seja este objetivo a minimização do tempo de execução, ou algo como a maximização do resultado da computação feita, existem diversas maneiras de se fazer esta otimização. Até certo tempo, a única maneira de se realizar isto era por testes e esforço direto do programador, envolvendo dificuldades de implementação, testes planejados, e complexidade teórica. A otimização automatizada surgiu de um desejo de se relegar a tarefa de encontrar a melhor maneira de se executar uma tarefa para o computador. Assim sendo, diversos arcabouços e aplicações surgiram, com o propósito de fazer esta otimização de forma automatizada.% --[Citation Needed]

\section{O OpenTuner}
%-explicar o que é, e o que esperamos dele
%-dar exemplos mais detalhados
%-incluir aqui nosso exemplo das árvores de habilidades
OpenTuner é um arcabouço para a implementação de sistemas de otimização e ajuste fino de programas. Utilizando um conjunto de técnicas empíricas de busca, o OpenTuner gera e testa combinações de parâmetros de configuração para um determinado programa, que podem representar por exemplo, escolhas algorítmicas.

Decidimos por estudar aplicações do OpenTuner no mundo real, em específico para jogos digitais. A ideia básica é que podemos usar o OpenTuner para otimizar um conjunto de parâmetros dentro do jogo, para ajudar o jogador a ter um planejamento, ou como uma metaferramenta de auxílio. Exemplos são a otimização de: parâmetros de inteligências artificiais para obter comportamentos desejáveis; parâmetros de geradores de mapas para obter ambientes variados com características comuns desejáveis; e a distribuição de pontos em personagens de um RPG (Role-Playing Game).

%TODO: Outras ideias
%Eram o que? SaltyBet, builds, IAs e gerção de mapa?
%OpenTTD vai onde?
\chapter{Ideias iniciais}
Inicialmente, desejávamos utilizar o OpenTuner em otimização de parâmetros em geradores de mapas. Seu propósito seria ser uma metaferramenta sobre o gerador de mapas de algum jogo, para otimizar a geração aleatória ou determinística de mapas com características desejáveis e quantificáveis.

Várias ideias de diferentes jogos possíveis foram sugeridas, e inicialmente concordamos em utilizar um gerador de mapas para o jogo DooM. Sendo um jogo consideravelmente antigo e simples, o trabalho seria também simples. Não só existem implementações open-source do mesmo, como conseguimos encontrar um gerador de mapas de simples uso que poderia ser autotunado.

Infelizmente, o fato de DooM ser um jogo muito antigo foi desfavorável ao projeto. Uma boa parte da comunidade de desenvolvedores de conteúdo sobre o jogo é extremamente antiga, com seus sites e fóruns foram desativados ou estão grandemente desatualizados. Mas o maior problema era  de ordem conceitual: como quantificar a qualidade de um mapa? Para o processo de autotuning, é necessário um resultado numérico, que não se pode derivar diretamente de um mapa. 
%Expandir essa ideia!
Pensamos em usar um bot como função de fitness para o mapa, mas novamente, encontramos uma comunidade e sites antigos e/ou desativados.

Próximo na lista de ideias estava a otimização da distribuição de pontos para um personagem de RPG. Para cada personagem, existe um conjunto de atributos, com pontos que podem ser distribuídos entre eles; para cada atributo, uma determinada quantidade de pontos afeta de forma diferente os resultados finais que um personagem pode ter no decorrer do jogo (um maior valor de Força, por exemplo, acarreta em ataques mais poderosos). Computacionalmente é uma questão muito mais simples, pois com este exemplo consegue-se derivar diretamente os valores a serem otimizados. Por exemplo, a quantidade de pontos de vida que um personagem possui, ou quantos pontos de dano o mesmo causa com um ataque.

A escolha de qual jogo se usaria de base então torna-se o problema. Deve-se considerar a complexidade do jogo em si, dado que isto influencia diretamente na maneira de se modelar a distribuição de pontos no OpenTuner. Foi iniciada a implementação de um tuner simples com uma árvore de habilidades genérica como exemplo, para podermos ver como o programa se comportaria, e se ele daria os resultados ótimos em um bom tempo.

Ideias de jogos a serem modelados foram: Torchlight 2, Path of Exile, The Elder Scrolls V: Skyrim, jogos do tipo Rogue-like, League of Legends, DOTA 2, e até algum possível sistema de RPG de mesa. Alguns destes foram descartados imediatemente por motivos como dificuldade de modelagem da árvore ou aleatoriedade demasiada envolvida no processo de testes.

Foi considerado então possivelmente trabalhar com os jogos Torchlight 2 ou The Elder Scrolls V: Skyrim. Estes dois jogos possuem árvores de habilidades razoavelmente simples conceitualmente, então era necessário verificar a viabilidade da interação dos mesmos com o Python, para fazer-se a interface com o OpenTuner. Novos problemas foram encontrados, na forma de incompatibilidades técnicas. As comunidades de desenvolvimento de conteúdo de Torchlight e de Skyrim trabalham primariamente com ferramentas fornecidas pelos desenvolvedores, que envolvem plataformas e linguagens de scripting próprias dos jogos, sem interação com linha de comando externa, ou possibilidade de alteração de atributos de personagem de fora do jogo. Em ambos os jogos, de maneiras similares, apenas é possível manipular o jogo com uma ferramenta externa própria, feita pelos desenvolvedores, ou internamente por um console isolado do sistema operacional, com comandos limitados. Adicionalmente, tentativas de alterar os arquivos de dados de personagem dos jogos mostraram-se demasiadamente complexas, por envolverem arquivos encriptados de forma complexa, e não existir nenhum método diretamente acessível de realizar esta decodificação.

%Inserir aqui o exemplo das árvores de habilidade!

Uma ideia que foi sugerida à parte destas outras, apenas pela discussão dos métodos, foi criar um bot que apostasse no site SaltyBet. Este site consiste de uma stream de vídeo com um jogo de luta sem jogadores, apenas com IAs controlando os personagens. Usuários que acessam o site podem apostar dinheiro virtual, referido como Salt Dollars, em qual personagem preferirem. O bot leria as entradas do chat, onde os personagens envolvidos e os resultados são anunciados, e daria estar informações para o OpenTuner. O OpenTuner, por sua vez, gravaria os resultados obtidos, e escolheria a \textit{a melhor estratégia de apostas} para decidir em qual personagem se apostaria, e quanto. Sendo apenas uma discussão de viabilidade, esta ideia não foi seguida.

Finalmente, o jogo que realmente chamou atenção para si neste estudo de viabilidade foi o OpenTTD. É um simulador de gerência de empresa de transportes, o que o distancia dos gêneros dos jogos estudados anteriormente. O que realmente causou a sua escolha para o projeto foram o fato de o mesmo ser um jogo de código aberto, e que existe uma simples maneira de interface com a linha de comando do sistema.

\chapter{OpenTTD}
\section{O jogo}
%-explicar os básicos sobre o jogo
%-explicar os nosso objetivos em aplicar o OpenTuner sobre ele
%-explicar como exatamente integramos os dois

%Miojo notes: OpenTTD se chama OpenTTD, simplesmente. Não é abreviação de Open Transport Tycoon Deluxe, embora seja </pedantic>
O OpenTTD \footnote{\url{www.openttd.org}}  é um clone de código aberto do clássico jogo Transport Tycoon Deluxe. Neste jogo, o jogador assume o papel de um administrador de uma empresa de transportes, e pode gerenciar e construir diversas redes de transporte, desde alugar e operar linhas de ônibus, até construir ferrovias e aeroportos. O objetivo do jogo é livre, sendo normalmente considerado apenas como criar uma linha de transporte eficiente, ou maximizar os lucros que sua empresa gera. Por esse fato, e pela simplicidade de lidar com o jogo, este foi escolhido para ser tratado neste trabalho.
 
OpenTTD foi baseado no jogo original de 1994, que recebeu um patch feito pela comunidade em 1996. A versão de código aberto foi lançada como uma derivação de tal patch chamado TTDPatch, que visava resolver alguns problemas de ordem técnica do jogo, além de adicionar algumas funcionalidades como novos gráficos, veículos,e indústrias. Entretanto,este patch não podia alterar facetas mais profundas do jogo original, e era limitado aos sistemas e plataformas nos quais este poderia ser executado. Seguindo o mesmo espírito deste patch, o OpenTTD foi criado como uma obra de engenharia reversa do jogo original, recriando-o em linguagem C. Este processo começou em 2003, por autoria de Ludvig Strigeus, que desejava uma maneira de continuar jogando Transport Tycoon Deluxe que se adaptasse à novas tecnologias, e pudesse ser modificado de maneiras mais profundas pela comunidade. O jogo foi lançado oficialmente em 2004, e até o ano de 2010, este ainda era dependente dos gráficos, músicas e efeitos sonoros do jogo original. Estes recursos foram gradualmente substituídos por versões feitas pela comunidade, tornando-o independente dos materiais do jogo original. %[Citation needed?] -> está no site deles, pegar a referência depois
%WebRef/Footnote pro About do site do OpenTTD

\section{Inteligências Artificiais}
%BEGIN RASCUNHO
%tenho minhas reservas quanto à isso ser um capítulo. Acho que seria melhor como subseção de OpenTTD

O OpenTTD tem suporte a inteligências artificiais, cujo comportamento é definido por um conjunto de scripts Squirrel , que é "uma linguagem de alto nível, imperativa e orientada a objetos, projetada para ser uma linguagem de script leve que se adequa aos requerimentos de banda, memória e processamento em tempo real para aplicações como jogos"\footnote{\url{www.squirrel-lang.org}}. Sua sintaxe é bastante similar à de C++. O OpenTTD tem seu próprio interpretador Squirrel, que executa um certo número de instruções de cada IA antes de interrompê-la por um breve período de tempo. Estes scripts são responsáveis por todas as ações que a IA pode tomar, como quais pontos de produção e consumo atender com seus veículos, como construir um caminho que atenda esse transporte, e quais veículos utilizar para isso.
%END RASCUNHO

\section{Objetivos}

%BEGIN RASCUNHO

Para avaliar a aplicabilidade de técnicas de ajuste fino em jogos, neste trabalho foi feito um \textit{tuner} para o vetor de custos de Pathfinding da IA, por ser um conjunto de valores mais simples de se trabalhar. Serão observados fatores como facilidade de implementação, funcionamento adequado e resultados obtidos. 

%Conseguir integrar? Ver se funciona? E resultados vem de brinde se funcionar e forem interessantes?

%END RASCUNHO

\section{Integração}

%Acho que aqui vai mais ou menos a estrutura do tuner?

Composto pelos módulos: TTDTuner, que interage com o OpenTuner, TTDHandler, que interage com o OpenTTD, e o AIBuilder, que constrói as IAs. Além destes, uma IA base que é uma versão modificada e incompleta dos arquivos da IA ChooChoo\footnote{\url{http://www.tt-forums.net/viewtopic.php?t=44225}}. Essa IA, além de ter os custos de pathfinding removidos para serem determinados pelo tuner, tem mensagens de saída adicionadas para relatar os resultados depois de um certo tempo. Existe um arquivo de configuração, o qual determina a pasta onde está a IA base, onde fica o diretório de IAs do OpenTTD, e qual o comando a ser utilizado para iniciar o OpenTTD. Por linha de comando, pode-se especificar qual valor será observado, quantos anos irá duras cada iteração da simulação, e quantas IAs existirão por iteração. Os valores medidos podem ser valor da empresa, lucro no último quartil, ou dinheiro em caixa.

O módulo que realiza a comunicação com o OpenTuner chama-se TTDTuner. Ele recebe as configurações do OpenTuner, escolhe um número de ID e inicia o AIBuilder, o qual controi uma IA e a coloca na pasta apropriada do OpenTTD; em seguida, o AIBuilder envia um sinal para o TTDHandler, que carrega estas IAs no jogo. O TTDTuner então aguarda o final da iteração, marcado pelo recebimento dos resultados vindos do TTDHandler, e então requisita que o mesmo reinicie a sessão de jogo. Por final, a média dos resultados é tirada e enviada para o OpenTuner.

O AIBuilder funciona substituindo linhas com palavras-chave pré-determinadas em cada um dos arquivos a serem modificados, com cada palavra-chave sendo mapeada a uma substituição diferente. A lista de palavras-chave e o mapeamento destas é independente para cada arquivo. O AIBuilder recebe um vetor de custos, um nome de parâmetro a ser avaliado, um número de anos e um ID do TTDTuner, que são usados para construir adequadamente as instruções que serão inseridas no código da IA gerada. O nome da IA é determinado pelo ID recebido, e é passado de volta para o TTDTuner.

O TTDHandler realiza a interface com o OpenTTD. Ele envia comandos para o servidor via pipe para o stdin do servidor e lê a saída retornada. O TTDHandler é responsável por iniciar IAs, parar IAs, ler respostas, e reiniciar o servidor quando necessário. Após iniciar as IAs, ele espera uma saída em formato específico vinda do jogo, formato este definido pelo padrão do OpenTTD e por uma convenção adotada para o ajuste fino realizado aqui. Ao detectar esta saída, que contém o resultado obtido e a identificação da IA, o TTDHandler concatena este resultado em um vetor de resultados, e devolve esse vetor quando todas as IAs terminarem.

Para realizar os testes e produzir resultados de forma mais eficiente, o OpenTTD foi compilado com uma alteração que permite a execução dos ciclos de jogo muito mais rapidamente, reduzindo drasticamente o tempo necessário para uma iteração completa do OpenTuner. Essa alteração não era necessária para o funcionamento pleno dos testes, mas agilizou dramaticamente a geração de resultados.

%\begin{figure}[h]
%\centering
%\includegraphics[width=0.7\linewidth]{Diagrama1}
%\caption[Estrutura do \textit{tuner} implementado]{}
%\caption{}
%\label{fig:Diagrama1}
%\end{figure}
%\chapter{Experimentos}

%BEGIN RASCUNHO

\begin{figure}
\centering
\includegraphics[width=0.7\linewidth]{Diagrama1}
\caption{Estrutura do \textit{tuner} implementado}
\label{fig:Diagrama1}
\end{figure}

Para verificar o funcionamento do Tuner, foram realizados testes de 10 e 50 anos com 8 IAs por iteração para valor da empresa, e de 10 anos com 6 IAs e 30 anos com 8 IAs para dinheiro em caixa e lucro. Testes de 10 anos foram executados numa máquina virtual cedida por Wilson Gnann, e os testes mais longos foram feitos na Rá, o servidor web do USPGameDev. A intenção original seria rodar esses testes por uma semana, mas instabilidades causando que os testes fossem interrompidos ocorriam em pontos imprevisíveis da execução, entre 8 e 72 horas após o início dos testes. Para os testes de caixa e lucro, o valor de semente inicial para o gerador de mapa do OpenTTD foi fixado, mas não durante os testes de valor da empresa. Esta alteração foi pensada depois dos testes iniciais, como uma maneira de eliminar a influência de aleatoriedade do ambiente do jogo sobre os resultados.

%END RASCUNHO
%-coisas que aconteceram

%-Estrutura do programa
% Construtor <-> Tuner <-> Handler <-> Server de OpenTTD
% OpenTTD gambiarrado pra gotta go fast
% Máquinas:
%  máquina virtual cedida pelo Gnann, carinhosamente chamada derrota
%  ra, o servidor web do uspgamedev
%  não zillertal porque faltava uma biblioteca que somehow só fazia falta de vez em quando e que eu esqueci de pedir pra instalarem

%Insofar, experimentos apenas com valor da companhia.
%Also, não guardamos as configurações. Deveríamos corrigir isso.

%Embora neste exemplo tenhamos apenas um capítulo,  entre a introdução
%e a conclusão de uma monografia podemos ter uma sequência de capítulos
%descrevendo o trabalho e os resultados. Estes podem descrever
%fundamentos, trabalhos relacionados, método/modelo/algoritmo proposto,
%experimentos realizados, resultados obtidos.
%
%Cada capítulo pode ser organizado em seções, que por sua vez pode
%conter subseções. 

%Um exemplo de figura está na figura~\ref{fig:graph}.
%\begin{figure}[htb]
%\includegraphics[width=5cm]{figuras/graph}
%\caption{\label{fig:graph}Exemplo de uma figura.}
%\end{figure}
