%% ------------------------------------------------------------------------- %%


\chapter{Conclusões}
\label{cap:conclusoes}

Apesar de todos os empecilhos, foi observado que o OpenTuner conseguiu melhorar os resultados observados modificando apenas o vetor de custos do algoritmo de Pathfinding usado pela IA. Mesmo esta sendo uma parte relativamente pequena de uma IA bastante complexa, e sem saber o funcionamento interno do jogo ou da IA, pode-se ver a diferença nos resultados obtidos. No momento, esses resultados podem ser questionáveis, devido à forma como o OpenTTD lida com as IAs, já que as medições podem ter tido uma variância considerável de tempo do jogo entre as medições.

Além disso, houve dificuldades em automatizar o OpenTTD, que não pôde ser compilado se simultaneamente não houvesse interface gráfica e networking, exigia um conjunto de gráficos mesmo sendo executado em modo servidor dedicado, e compilava e carregava IAs pela primeira vez sem problemas sem suporte à biblioteca libzlo2, mas falhava ao reiniciar o jogo se fosse compilado dessa forma.
%Será que isso merece um bug report, se ainda não existir? 

Com isso em mente, talvez seja possível obter resultados melhores se o jogo for desenvolvido desde o começo para ser automatizado, e utilizando uma estrutura de \textit{tuner} que aproveite melhor as características do OpenTuner.
%Aliás, se a gente for pra Rec, eu já tenho algo em mente, mas que não vai dar tempo de fazer no momento.


%Provavelmente funciona yaaaaaaay mas provavelmente rende mais se o jogo for projetado assim desde o começo yaaaaaaaaay

\chapter{Renan Teruo Carneiro}
\section{Desafios e Frustrações}

Tivemos dificuldades em achar um jogo bom para realizar o tuning. Queríamos evitar criar um jogo só para isso, especialmente dado que as ideias iniciais exigiriam muito esforço só para desenvolver a parte a ser otimizada, e isso sem contar a implementação do tuner em si. Porém, praticamente todos os jogos que chegamos a discutir tinha algum problema, especialmente para automatizar os testes necessários para o processo. Além disso, extrair os dados gerados e analisá-los externamente seria difícil, devido à forma como são guardados, como também exigiria um conhecimento mais profundo de mecânicas e jogabilidade do jogo para ter uma modelagem aceitável, derrotando de certa forma o propósito de usar o OpenTuner.

A falta de paralelismo na execução de testes do OpenTuner também foi um problema, já que no nosso caso, já que o jogo roda numa única thread, isso faria sentido. Seria possível usar uma parte do OpenTuner de forma meio errada para subverter isso, mas com seus próprios problemas. Outro problema decorrente disso é a estrutura do Handler, que foi inicialmente projetado para interagir com diversas threads, cada uma correspondente a cada uma das IAs que estariam todas rodando no mesmo servidor. Essa estrutura acabou ficando complexa demais para o funcionamento atual, e isso pode ter sido um dos fatores que ocasionaram as falhas na execução de testes.

Falando das falhas, essas foram um problema curioso. Não percebemos nenhum indício que aponta mais precisamente por que alguma coisa em algum momento parava de funcionar. Na Rá,simplesmente executava um número não fixo de iterações por um período de tempo não fixo e parava, sem mais mensagens, inclusive as de erros. Na máquina virtual, provavelmente acabava algum recurso eventualmente, já que acusava um erro de não adquirir um lock que era adquirido na linha imediatamente anterior. Ainda assim, não conseguimos identificar qual recurso estava vazando, e se isso de fato acontecia.

%achar um aspecto de um jogo pra ser otimizado\\
%achar um jogo que fosse ao mesmo tempo simples de se trabalhar, e que tivesse algo interessante a ser otimizado\\
%aaaaa porque tudo está tão desatualizado ou perdido na internet\\
%aaaaa porque continua crashando? (maquinas clandestinas)\\
%aaaaa porque não paralelismo nos testes?\\

\section{Disciplinas Relacionadas}
Inteligência Artificial, já que estávamos alterando um vetor de custos de um A*.\\
Aprendizagem Computacional, que é basicamente a base de tudo isso.\\
Programação Concorrente para lidar com a estrutura que deveria ser multithreaded do tuner mas que acabou não sendo.\\
Redes teria sido útil se o OpenTuner fosse paralelizado, já que íamos fazer um tuner cujas threads se comunicariam com o handler através de conexões no localhost, mas isso nunca foi implementado.\\
Laboratório de Programação porque Git e Latex.\\
Laboratório de Programação II porque POO simples. 

\chapter{Vitor Cerqueira Santos}
\section{Desafios e Dificuldades}
Tivemos diversos desafios durante o ano no desenvolvimento deste trabalho. A começar por pensar em qual aspecto de um jogo seria otimizado, porque isto envolvia escolher um jogo que pudesse ter este aspecto explorado. A busca por um jogo que fosse simultaneamente acessível tecnicamente e que possuísse um aspecto interessante a ser otimizado. Chegamos a considerar criar um jogo simples para ser otimizado, mas isto geraria uma necessidade muito maior de esforço, que não seria viável para este trabalho.

Na pesquisa necessária para escolher o jogo a ser trabalhado, diversos outros problemas foram encontrados. Muitas vezes, encontramos uma ideia interessante, mas não encontramos uma maneira de implementá-la, pois muitas informações e recursos de que necessitávamos estavam ora indisponíveis, ora extremamente desatualizadas (como por exemplo, recursos para o jogo DooM original, onde encontramos sites de antes do ano 2000). Nos jogos onde conseguimos encontrar as informações necessárias, descobrimos que muitos deles não eram compatíveis com o método de interface do OpenTuner, que interage com outros programas via entrada e saída de linha de comando. 

Ainda no quesito de se escolher o jogo e o que seria otimizado, passamos também por problemas de ordem conceitual. A primeira ideia que tentamos seguir era a de otimizar um gerador de mapas. O problema aqui é como derivaríamos uma avaliação do mapa gerado de uma maneira que o OpenTuner pudesse avaliar se determinado mapa era melhor ou pior que outro mapa gerado. Nesta época, tivemos a ideia de realizar uma "otimização dupla", em que ajustaríamos o gerador de mapas, e o avaliaríamos com uma IA jogando uma partida de teste no mesmo. Por complexidade demasiada deste método, a ideia foi abandonada.

Por fim, outro desafio foi a parte do trabalho que envolveu pesquisa teórica. Sendo uma área de pesquisa tão nova e inexplorada, não existem muitos outros artigos ou fontes no assunto. Na verdade, não conseguimos encontrar outro trabalho que relacione \textit{autotuning} usado em jogos digitais da maneira que fizemos. Entre os trabalhos relacionados que foram encontrados, tivemos alguma dificuldade inicial em compreendê-los completamente, pois é um assunto razoavelmente complexo.

\section{Disciplinas Relacionadas}
Uhhh as de computação genéricas?\\
IA\\
Concorrente?\\

\chapter{Trabalhos Futuros}

Futuramente, uma possibilidade seria verificar a aplicabilidade das técnicas de ajuste fino durante o desenvolvimento de um jogo, projetado desde o início com isso em mente, e avaliar as consequências positivas e negativas decorrentes. Também poderia haver uma exploração de potenciais alvos de otimização, e seu possível impacto sobre desenvolvimento e design do jogo.

%Texto texto texto texto texto texto texto texto texto texto texto texto texto
%texto texto texto texto texto texto texto texto texto texto texto texto texto
%texto texto texto texto texto texto\footnote{Exemplo de referência para página
%Web: \url{www.vision.ime.usp.br/~jmena/stuff/tese-exemplo}}.

